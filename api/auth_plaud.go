package api

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/Plaud-AI/plaud-go-scaffold/pkg/logger"
)

// PlaudAuthService 调用 plaud-api 的鉴权服务
type PlaudAuthService struct {
	baseURL    string
	httpClient *http.Client
}

// NewPlaudAuthService 创建 PlaudAuthService
func NewPlaudAuthService(baseURL string) *PlaudAuthService {
	return &PlaudAuthService{
		baseURL: strings.TrimSuffix(baseURL, "/"),
		httpClient: &http.Client{
			Timeout: 10 * time.Second,
		},
	}
}

// VerifyUserResponse plaud-api /auth/verify-user 接口响应
type VerifyUserResponse struct {
	Status int    `json:"status"`
	Msg    string `json:"msg"`
	Data   *struct {
		UserID   string        `json:"user_id"`
		Accounts []AccountInfo `json:"accounts"`
	} `json:"data"`
}

// AccountInfo 账户信息
type AccountInfo struct {
	Type    string `json:"type"`              // email, phone, sso
	Subtype string `json:"subtype,omitempty"` // google, apple, wechat 等（仅 sso 类型）
	Value   string `json:"value"`
}

// ValidateToken 验证 token 并返回用户信息
func (s *PlaudAuthService) ValidateToken(ctx context.Context, token string) (*AuthUserInfo, error) {
	if token == "" {
		return nil, errors.New("token is empty")
	}

	// 调用 plaud-api 的 /auth/verify-user 接口
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, s.baseURL+"/auth/verify-user", nil)
	if err != nil {
		return nil, fmt.Errorf("create request failed: %w", err)
	}

	// 传递 Authorization header
	req.Header.Set("Authorization", token)

	resp, err := s.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusUnauthorized {
		return nil, errors.New("invalid token")
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	var result VerifyUserResponse
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("decode response failed: %w", err)
	}

	if result.Status != 0 || result.Data == nil {
		return nil, fmt.Errorf("auth failed: %s", result.Msg)
	}

	// 从 accounts 中提取邮箱，应用过滤逻辑
	email := extractEmail(result.Data.Accounts)
	if email == "" {
		logger.WarnfCtx(ctx, "user %s has no valid email", result.Data.UserID)
	}

	return &AuthUserInfo{
		UserID: result.Data.UserID,
		Email:  email,
	}, nil
}

// extractEmail 从账户列表中提取有效邮箱
// 逻辑参考 plaud-api/service/user.py 中的 get_user_email 函数：
// 1. 优先取 email 类型的账户，但排除自动生成的邮箱（apple-xxx@plaud.ai, google-xxx@plaud.ai, microsoft-xxx@plaud.ai）
// 2. 如果没有有效的 email，则取 sso 类型的邮箱，但排除 apple 类型
func extractEmail(accounts []AccountInfo) string {
	// 第一遍：查找有效的 email 类型账户
	for _, acc := range accounts {
		if acc.Type == "email" && acc.Value != "" {
			// 排除自动生成的邮箱
			if !isAutoGeneratedEmail(acc.Value) {
				return acc.Value
			}
		}
	}

	// 第二遍：查找有效的 sso 邮箱（排除 apple）
	for _, acc := range accounts {
		if acc.Type == "sso" && acc.Value != "" && acc.Subtype != "apple" {
			// SSO 的 value 可能是邮箱格式
			if strings.Contains(acc.Value, "@") {
				return acc.Value
			}
		}
	}

	return ""
}

// isAutoGeneratedEmail 判断是否为自动生成的邮箱
// 格式为：apple-xxx@plaud.ai, google-xxx@plaud.ai, microsoft-xxx@plaud.ai
func isAutoGeneratedEmail(email string) bool {
	if !strings.HasSuffix(email, "@plaud.ai") {
		return false
	}
	return strings.HasPrefix(email, "apple-") ||
		strings.HasPrefix(email, "google-") ||
		strings.HasPrefix(email, "microsoft-")
}
